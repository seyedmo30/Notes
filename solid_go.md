

# Single Responsibility

این اصل میگه هر کلاس باید یک کار را انجام دهد به عبارت دیگر یک کلاس فقط باید به یک دلیل تغییر کنه

برای رعایت این اصل ، یکی از نکات این است که ریسیور های استراکچر را با دقت بنویسیم ، زیرا شاید یه استراکت بیش از چند ریسیور داشته باشد و در نتیجه بیش از یک کار انجام دهد


# Open/close

برای رعایت این اصل ، باید برنامه جوری نوشته شده باشه که در صورتی که بخوایم تغییری در آینده ایجاد کنیم ، تنها چیزی به برنامه اضافه کنیم و کد های قبلی دچار تغییر زیاد یا حذف نشن



# Liskov

میگه که در صورتی که از یک شی ، چند نمونه بسازیم ، باید برنامه جوری باشه که اگر نمونه ها را جا بجا کنیم ، برنامه به خطا نخوره


برای رعایت این اصل ، باید در ایجاد وراثت دقت کنیم ، مثلا اگر کلاس پدر یک متد دارد ، نباید کلاس فرزند همان متد را داشته باشد 


مثلا برای ساخت مسطیل نیاز به عرض و طول داریم در حالی که برای مربع نیازی به هر دو نداریم 


    
# Interface Segregation
    
کلاس‌ها نباید مجبور باشن متدهایی که به اونها احتیاجی ندارن رو پیاده‌سازی کنن ، اینترفیس (Interface) ها رو جوری بنویسیم که وقتی یک کلاس از اون استفاده میکنه، مجبور نباشه متدهایی که لازم نداره رو پیاده‌سازی کنه. یعنی متدهای بی‌ربط نباید توی یک اینترفیس کنار هم باشن 
    
یا اینکه بخاطر اینکه یک اینترفیس را پیاده سازی کنیم ، مجبور باشیم متد های بی خاصیتی بسازیم که فقط چارچوب اینترفیس را امپلمنت کرده باشیم

# Dependency Inversion
 
 کلاس‌های سطح بالا نباید به کلاس‌های سطح پایین وابسته باشن؛ هر دو باید وابسته به انتزاع (Abstractions) باشن. موارد انتزاعی نباید وابسته به جزییات باشن. جزییات باید وابسته به انتزاع باشن

اگر این اصل را رعایت نکنیم ، برای یونیک تست، باید تمام نیاز های Use case را پیاده سازی کینم.

از کاربرد های این اصل ، می توان به رفع dependency injection اشاره کرد . یکی از رایج ترین راه های decoupl کردن کد :مثلا  فرض کنید یک Use case ( زیر سرویس ) داریم و می خواهیم وابستگی آن به کانفیگ دیتا بیس رو با اینترفیس حل کنیم . 









