value مقدار ( مثل ۶ یا علی )

variable ظرفی که ولیو داخلش ریخته می شه (مثل کانست یا لت یا ور)

data type نوع ظرف ( مثل استرینگ یا اینت)

data structure مجموعه یا گروهی از دیتا تایپ ها (مثل لیست یا درخت یا مپ یا دیکشنری)

type casting اگر بخواهیم تایپ یک ظرف(وریبل) را تغییر دهیم - مثلا اینت به فلوت- که گو ندارد

conversion برای این که ولیو(مقدار) با تایپ خاص ، در یک ظرف(وریبل) با تایپ متفاوت بریزیم ، راه هایی دارد که آنها را کانورژن می گوییم

race condition اگر دو دستور بخواهند مقدار یک وریبل را همزمان تغییر دهند ، برای جلو گیری از ریس کاندیشن از mutex استفاده می کنیم

type embedding به این معناست که ما می توانیم هرتایپی را درون استراکت بزاریم ، اینجا مقصود اینترفیس است که می توان در استراکت ، یک پراپرتی باشد

deadlock زمانی که بافر چنل ها پر شود، وگوروتین ها منتظرخالی شدن چنل برای ریختن داده در آن هستند ، در حالی که خالی نمی شود ، اصطلاحا می گن ددلاک شده ،همچنین اگه چنل خالی باشه و یک گوروتین منتظر که داده از چنل برداره و همه گوروتین ها منتظرن ، باز هم دد لاک میشه

blank identifier    شناسه خالی

اگر یک فانکشن  خروجی داشت و ما خروجی ها را نادیده گرفته‌ایم ، آن را با  _  نمایش می دهیم یعنی خروجی را نادیده می گیریم

      _,res := Double(8)


string format  میتوان داخل استرینگ با علامت درصد مقدار جایگذاری کرد


stack trace error   ردپای خطا

به این معناست که بفهمیم خطا از کجا شروع شده ، یعنی اگر پیام خطا در بیرونی ترین لایه ی برنامه نمایش داده شد ، بتوانیم اولین مرحله بروز خطا را پیدا کنیم

در گولنگ این پکیج مناسب است

go get github.com/pkg/errors


Sentinel Errors خطای نگهبان

یکی از راه های پیش بینی خطا ، این است که خطا را ابتدا تعریف کنیم ( پیام خطا را ) و در کد ، متوانیم با استفاده از IS چک کنیم که خطای پیش آمده برابر خطای پیش بینی شده است یا خیر .

بدی این روش این است که باید تمامی خطا ها را از پکیج آن امپورت کنیم و شاید این روند خیلی پیچیده و بزرگ شود

Custom Error Types تایپ دستی خطا

در این روش می توانیم با توجه با اینترفیس ارور ، علاوه بر پیام ارور ، مقدار های دیگری هم به استراکت بیفزاییم ( یعنی ساختار خطا را تغییر دهیم) . 

حال در صورت رخ دادن ارور ، با استفاده از errors.As چک کنیم ساختار ارور ، با ساختار پیش بینی شده یکسان است یا خیر .

در این روش هم می بایست تایپ های ارور را پابلیک کرد و در تمامی کد باید فراخوانی شود و این خود مشکل است .

https://earthly.dev/blog/golang-errors/

Error wrapping بسته بندی خطا

در این روش ، می توانیم هر جا که به ارور خوردیم در پیام آن ، یک لایه متن ، رپ کنیم و به مرحله بعد دهیم ، هر موقع کاربر خواست می تواند لایه های خطا را ببیند 

توجه شود که wrap کردن با Sentinel Errors و Error Types ناسازگار است  
