### concurrency vs parallelism 

در کانکارنت می توان یک سرویس را شتکست و به چند زیر سرویس تبدیل کرد و هر کدام را همزمان انجام داد اما در پارالل یک سرویس کامل را همزمان اجرا میکینم . در پارالل هر سرویس بر روی یک ترد پراسس می شود در حالی که در کانکارنت چندین تسک می توان بر روی یک ترد پراسس شود همچنین در کانکارنت ترتیب و نظم اهمیتی ندارد


mutex

در بیشتر مثال ها داده درون یک استراکت ، همراه mutex است 


type SafeCounter struct {
	mu sync.Mutex
	v  map[string]int
}

همچنین getter setter آن ، ریسیور هایی هست که دسترسی به داده دارند . همچنین می توان از ... برای این قابلیت که همزمان بتوان داده را چند گوروتین خواند ولی تنها یک گوروتین بتوان آن را تغییر داد ، استفاده کرد .

## انواع چنل ها
### buff
+ unbuffer - زمانی که بخواهیم داده سینک دریافت کنیم
+ buffered - نیاز به گرفتن داده به صورت همزمان نباشد - آسینک

  توجه: چنل آنبافر  یعنی طول صفر است ! یعنی اگر به چنل آنبافر بعد از ساختن ، مقدار دهیم ددلاک می شود! تنها در صورتی می توان استفاده کرد که در گوروتین جدا ابتدا منتظر برداشتن از چنل باشیم و به محض ریختن در چنل آنبافر، آن برداشته شود . در نتیحه ابتدا باید منتظر باشیم سپس داده در آن بریزیم .

### Directional
+ send-only - chan<- - از دید کلاینت ، فقط می توان به چنل داده فرستاد
+ recevie-only - <-chan - از دید کلاینت ، فقط می توان از چنل داده دریافت کرد

### receive channel ? return ? or pass as parameter
می توانیم چنل خروجی تابع  را یا در ریترن بزاریم ، یا در پارامتر های ورودی

+ Return the channel directly as a return value
در این حالت مدیریت چنل دست فانکشن است ، احتمالن فانکشن عمری طولانی خواهد داشت و در پایان برنامه تابعد قبل از اتمام می تواند چنلی که ساخته را کلوز کند .

+ Pass the channel as a parameter:
در این حالت مدیریت چنل بر عهده ی سوپر فانکشن است ، احتمالن هر بار فانکشن ساخته شده و کارش به پایان می رسد ، بیشتر برای زمانی که می خوهیم برای هر در خواست یک فانکشن بسازیم

فقط توجه کنید در این صورت اگر ارتباط بین فانکشن و سوپر فانکشن قطع شود ، مدیریت آن خیلی سخت می شود ، بهتر است یک چنل برای ارتباط با سوپر فانکشن بگذاریم

### receive data from chan
به طور کلی به ۳ روش می توان از چنل داده برداشت کرد :
+ ساده
  

		 x := <-ch 
		 fmt.Println(x)
	  
+ انتخاب بین چند چنل

	      for {
	        select {
	        case x, ok := <-ch1:
	            if ok {
	                fmt.Println("Received from ch1:", x)
	            } else {
	                fmt.Println("ch1 closed")
	                ch1 = nil // set ch1 to nil to stop receiving from it
	            }
	        case x, ok := <-ch2:
	  

+ در حلقه ی 

		for i := range ch {
		    fmt.Println(i)
		}

سوالات خوب مصاحبه :

https://www.tutorialspoint.com/articles/category/go-programming
